// ============================================================================
// NISHI – Documentation Management
//
// Manages structured documentation for context engineering:
// - PROJECT.md: Vision and direction
// - REQUIREMENTS.md: Scoped requirements
// - ROADMAP.md: Progress tracking
// - STATE.md: Decisions and blockers
// - PLAN.md: XML-structured tasks
// ============================================================================

import fs from 'node:fs';
import path from 'node:path';
import logger from './logger.js';

export const PLANNING_DIR = '.planning';

export interface ProjectDoc {
  name: string;
  vision: string;
  goals: string[];
  constraints: string[];
  technicalStack: string[];
}

export interface RequirementDoc {
  functional: string[];
  nonFunctional: string[];
  integrations: string[];
  outOfScope: string[];
}

export interface Phase {
  number: number;
  name: string;
  description: string;
  status: 'pending' | 'in-progress' | 'completed';
  tasks?: number;
  completedTasks?: number;
}

export interface RoadmapDoc {
  milestones: Array<{
    name: string;
    version: string;
    phases: Phase[];
  }>;
  currentMilestone: string;
  currentPhase?: number;
}

export interface StateDoc {
  decisions: Array<{
    date: string;
    decision: string;
    rationale: string;
  }>;
  blockers: Array<{
    phase?: number;
    description: string;
    status: 'open' | 'resolved';
  }>;
  notes: string[];
}

/**
 * Ensure .planning directory exists
 */
export function ensurePlanningDir(): void {
  if (!fs.existsSync(PLANNING_DIR)) {
    fs.mkdirSync(PLANNING_DIR, { recursive: true });
    logger.success(`Created ${PLANNING_DIR}/ directory`);
  }
}

/**
 * Create PROJECT.md
 */
export function createProjectDoc(data: ProjectDoc): void {
  ensurePlanningDir();

  const content = `# ${data.name}

## Vision
${data.vision}

## Goals
${data.goals.map(g => `- ${g}`).join('\n')}

## Constraints
${data.constraints.map(c => `- ${c}`).join('\n')}

## Technical Stack
${data.technicalStack.map(t => `- ${t}`).join('\n')}

---
*Generated by NISHI on ${new Date().toISOString().split('T')[0]}*
`;

  fs.writeFileSync(path.join(PLANNING_DIR, 'PROJECT.md'), content);
  logger.success('Created PROJECT.md');
}

/**
 * Create REQUIREMENTS.md
 */
export function createRequirementsDoc(data: RequirementDoc): void {
  ensurePlanningDir();

  const content = `# Requirements

## Functional Requirements
${data.functional.map((r, i) => `${i + 1}. ${r}`).join('\n')}

## Non-Functional Requirements
${data.nonFunctional.map((r, i) => `${i + 1}. ${r}`).join('\n')}

## Integrations
${data.integrations.map(i => `- ${i}`).join('\n')}

## Out of Scope
${data.outOfScope.map(o => `- ${o}`).join('\n')}

---
*Generated by NISHI on ${new Date().toISOString().split('T')[0]}*
`;

  fs.writeFileSync(path.join(PLANNING_DIR, 'REQUIREMENTS.md'), content);
  logger.success('Created REQUIREMENTS.md');
}

/**
 * Create or update ROADMAP.md
 */
export function updateRoadmap(data: RoadmapDoc): void {
  ensurePlanningDir();

  const milestoneContent = data.milestones.map(m => {
    const phaseContent = m.phases.map(p => {
      const statusIcon = p.status === 'completed' ? '✓' : p.status === 'in-progress' ? '→' : '○';
      const progress = p.tasks ? ` (${p.completedTasks || 0}/${p.tasks})` : '';
      return `  ${statusIcon} **Phase ${p.number}: ${p.name}**${progress}\n     ${p.description}`;
    }).join('\n\n');

    return `### Milestone: ${m.name} (${m.version})
${m.version === data.currentMilestone ? '*Current*' : ''}

${phaseContent}`;
  }).join('\n\n---\n\n');

  const content = `# Roadmap

**Current Milestone:** ${data.currentMilestone}
${data.currentPhase ? `**Current Phase:** ${data.currentPhase}` : ''}

---

${milestoneContent}

---
*Updated by NISHI on ${new Date().toISOString().split('T')[0]}*
`;

  fs.writeFileSync(path.join(PLANNING_DIR, 'ROADMAP.md'), content);
  logger.success('Updated ROADMAP.md');
}

/**
 * Read ROADMAP.md
 */
export function readRoadmap(): RoadmapDoc | null {
  const roadmapPath = path.join(PLANNING_DIR, 'ROADMAP.md');
  if (!fs.existsSync(roadmapPath)) {
    return null;
  }

  // Basic parsing - in production you'd want more robust parsing
  // const content = fs.readFileSync(roadmapPath, 'utf-8');

  // For now, return a minimal structure
  // In production, parse the markdown properly
  return {
    milestones: [],
    currentMilestone: 'v1.0.0',
  };
}

/**
 * Create or update STATE.md
 */
export function updateState(data: StateDoc): void {
  ensurePlanningDir();

  const decisionsContent = data.decisions.length > 0
    ? data.decisions.map(d => `### ${d.date}\n**Decision:** ${d.decision}\n**Rationale:** ${d.rationale}`).join('\n\n')
    : '*No decisions recorded yet*';

  const blockersContent = data.blockers.length > 0
    ? data.blockers.map(b => {
        const status = b.status === 'resolved' ? '✓' : '⚠';
        const phase = b.phase ? `[Phase ${b.phase}] ` : '';
        return `${status} ${phase}${b.description}`;
      }).join('\n')
    : '*No blockers*';

  const notesContent = data.notes.length > 0
    ? data.notes.map(n => `- ${n}`).join('\n')
    : '*No notes*';

  const content = `# Project State

## Decisions

${decisionsContent}

## Blockers

${blockersContent}

## Notes

${notesContent}

---
*Updated by NISHI on ${new Date().toISOString().split('T')[0]} at ${new Date().toTimeString().split(' ')[0]}*
`;

  fs.writeFileSync(path.join(PLANNING_DIR, 'STATE.md'), content);
  logger.success('Updated STATE.md');
}

/**
 * Read STATE.md
 */
export function readState(): StateDoc | null {
  const statePath = path.join(PLANNING_DIR, 'STATE.md');
  if (!fs.existsSync(statePath)) {
    return null;
  }

  // For now, return empty structure
  // In production, parse the markdown properly
  return {
    decisions: [],
    blockers: [],
    notes: [],
  };
}

/**
 * Read PROJECT.md
 */
export function readProject(): ProjectDoc | null {
  const projectPath = path.join(PLANNING_DIR, 'PROJECT.md');
  if (!fs.existsSync(projectPath)) {
    return null;
  }

  // For now, return minimal structure
  // In production, parse PROJECT.md properly
  return {
    name: 'Project',
    vision: '',
    goals: [],
    constraints: [],
    technicalStack: [],
  };
}

/**
 * Read REQUIREMENTS.md
 */
export function readRequirements(): RequirementDoc | null {
  const reqPath = path.join(PLANNING_DIR, 'REQUIREMENTS.md');
  if (!fs.existsSync(reqPath)) {
    return null;
  }

  // For now, return minimal structure
  // In production, parse REQUIREMENTS.md properly
  return {
    functional: [],
    nonFunctional: [],
    integrations: [],
    outOfScope: [],
  };
}

/**
 * Create phase directory and PLAN.md
 */
export function createPhasePlan(phaseNumber: number, planXML: string): void {
  ensurePlanningDir();

  const phaseDir = path.join(PLANNING_DIR, `phase-${phaseNumber}`);
  if (!fs.existsSync(phaseDir)) {
    fs.mkdirSync(phaseDir, { recursive: true });
  }

  const content = `# Phase ${phaseNumber} Plan

${planXML}

---
*Generated by NISHI on ${new Date().toISOString()}*
`;

  fs.writeFileSync(path.join(phaseDir, 'PLAN.md'), content);
  logger.success(`Created phase-${phaseNumber}/PLAN.md`);
}

/**
 * Read phase plan
 */
export function readPhasePlan(phaseNumber: number): string | null {
  const planPath = path.join(PLANNING_DIR, `phase-${phaseNumber}`, 'PLAN.md');
  if (!fs.existsSync(planPath)) {
    return null;
  }
  return fs.readFileSync(planPath, 'utf-8');
}

/**
 * Create config.json
 */
export function createConfig(config: Record<string, unknown>): void {
  ensurePlanningDir();

  const defaultConfig = {
    mode: 'interactive',
    depth: 'standard',
    profile: 'balanced',
    agents: {
      research: true,
      planning: true,
      verification: true,
    },
    git: {
      autoCommit: true,
      commitPrefix: 'feat',
    },
    sdlc: {
      jira: { enabled: false },
      confluence: { enabled: false },
      bitbucket: { enabled: false },
    },
    ...config,
  };

  fs.writeFileSync(
    path.join(PLANNING_DIR, 'config.json'),
    JSON.stringify(defaultConfig, null, 2)
  );

  logger.success('Created config.json');
}

/**
 * Read config.json
 */
export function readConfig(): Record<string, unknown> | null {
  const configPath = path.join(PLANNING_DIR, 'config.json');
  if (!fs.existsSync(configPath)) {
    return null;
  }

  const content = fs.readFileSync(configPath, 'utf-8');
  return JSON.parse(content) as Record<string, unknown>;
}

/**
 * Update config.json
 */
export function updateConfig(updates: Record<string, unknown>): void {
  const current = readConfig() || {};
  const updated = { ...current, ...updates };

  fs.writeFileSync(
    path.join(PLANNING_DIR, 'config.json'),
    JSON.stringify(updated, null, 2)
  );

  logger.success('Updated config.json');
}

/**
 * Initialize project structure
 */
export function initializeProject(
  project: ProjectDoc,
  requirements: RequirementDoc,
  roadmap: RoadmapDoc
): void {
  ensurePlanningDir();
  createProjectDoc(project);
  createRequirementsDoc(requirements);
  updateRoadmap(roadmap);
  updateState({
    decisions: [
      {
        date: new Date().toISOString().split('T')[0]!,
        decision: 'Project initialized with NISHI',
        rationale: 'Structured approach to prevent context rot and maintain quality',
      },
    ],
    blockers: [],
    notes: ['Project structure created', 'Ready to begin Phase 1'],
  });
  createConfig({});
  logger.success('Project initialized successfully!');
}

/**
 * Add a new phase to the current milestone
 */
export function addPhase(
  name: string,
  description: string,
  milestoneVersion?: string
): void {
  const roadmap = readRoadmap();
  if (!roadmap) {
    logger.error('No roadmap found. Run /nishi:new-project first.');
    return;
  }

  const targetVersion = milestoneVersion || roadmap.currentMilestone;
  const milestone = roadmap.milestones.find(m => m.version === targetVersion);

  if (!milestone) {
    logger.error(`Milestone ${targetVersion} not found`);
    return;
  }

  const nextPhaseNumber = milestone.phases.length + 1;
  const newPhase: Phase = {
    number: nextPhaseNumber,
    name,
    description,
    status: 'pending',
  };

  milestone.phases.push(newPhase);
  updateRoadmap(roadmap);

  logger.success(`Added Phase ${nextPhaseNumber}: ${name}`);

  // Update state
  const state = readState() || { decisions: [], blockers: [], notes: [] };
  state.notes.push(`Phase ${nextPhaseNumber} added: ${name}`);
  updateState(state);
}

/**
 * Insert a phase at a specific position
 */
export function insertPhase(
  position: number,
  name: string,
  description: string,
  milestoneVersion?: string
): void {
  const roadmap = readRoadmap();
  if (!roadmap) {
    logger.error('No roadmap found. Run /nishi:new-project first.');
    return;
  }

  const targetVersion = milestoneVersion || roadmap.currentMilestone;
  const milestone = roadmap.milestones.find(m => m.version === targetVersion);

  if (!milestone) {
    logger.error(`Milestone ${targetVersion} not found`);
    return;
  }

  if (position < 1 || position > milestone.phases.length + 1) {
    logger.error(`Invalid position. Must be between 1 and ${milestone.phases.length + 1}`);
    return;
  }

  // Create new phase
  const newPhase: Phase = {
    number: position,
    name,
    description,
    status: 'pending',
  };

  // Insert and renumber
  milestone.phases.splice(position - 1, 0, newPhase);
  milestone.phases.forEach((phase, index) => {
    phase.number = index + 1;
  });

  updateRoadmap(roadmap);
  logger.success(`Inserted Phase ${position}: ${name}`);

  // Update state
  const state = readState() || { decisions: [], blockers: [], notes: [] };
  state.notes.push(`Phase ${position} inserted: ${name}`);
  updateState(state);
}

/**
 * Remove a phase from the roadmap
 */
export function removePhase(phaseNumber: number, milestoneVersion?: string): void {
  const roadmap = readRoadmap();
  if (!roadmap) {
    logger.error('No roadmap found. Run /nishi:new-project first.');
    return;
  }

  const targetVersion = milestoneVersion || roadmap.currentMilestone;
  const milestone = roadmap.milestones.find(m => m.version === targetVersion);

  if (!milestone) {
    logger.error(`Milestone ${targetVersion} not found`);
    return;
  }

  const phaseIndex = milestone.phases.findIndex(p => p.number === phaseNumber);
  if (phaseIndex === -1) {
    logger.error(`Phase ${phaseNumber} not found`);
    return;
  }

  const phase = milestone.phases[phaseIndex]!;

  // Check if phase is in progress or completed
  if (phase.status === 'in-progress') {
    logger.warn('Phase is in progress. Are you sure you want to remove it?');
  }

  // Remove and renumber
  const removedPhase = milestone.phases.splice(phaseIndex, 1)[0]!;
  milestone.phases.forEach((p, index) => {
    p.number = index + 1;
  });

  updateRoadmap(roadmap);
  logger.success(`Removed Phase: ${removedPhase.name}`);

  // Update state
  const state = readState() || { decisions: [], blockers: [], notes: [] };
  state.notes.push(`Phase removed: ${removedPhase.name}`);
  updateState(state);
}

/**
 * Mark a phase as complete
 */
export function completePhase(phaseNumber: number, milestoneVersion?: string): void {
  const roadmap = readRoadmap();
  if (!roadmap) {
    logger.error('No roadmap found. Run /nishi:new-project first.');
    return;
  }

  const targetVersion = milestoneVersion || roadmap.currentMilestone;
  const milestone = roadmap.milestones.find(m => m.version === targetVersion);

  if (!milestone) {
    logger.error(`Milestone ${targetVersion} not found`);
    return;
  }

  const phase = milestone.phases.find(p => p.number === phaseNumber);
  if (!phase) {
    logger.error(`Phase ${phaseNumber} not found`);
    return;
  }

  phase.status = 'completed';

  // Update current phase to next pending phase
  const nextPendingPhase = milestone.phases.find(p => p.status === 'pending');
  if (nextPendingPhase) {
    roadmap.currentPhase = nextPendingPhase.number;
  } else {
    delete roadmap.currentPhase;
  }

  updateRoadmap(roadmap);
  logger.success(`✓ Phase ${phaseNumber} completed: ${phase.name}`);

  // Update state
  const state = readState() || { decisions: [], blockers: [], notes: [] };
  state.decisions.push({
    date: new Date().toISOString().split('T')[0]!,
    decision: `Phase ${phaseNumber} completed`,
    rationale: `All tasks in ${phase.name} verified and committed`,
  });
  updateState(state);
}

/**
 * Start a new milestone
 */
export function newMilestone(
  name: string,
  version: string,
  initialPhases: Array<{ name: string; description: string }>
): void {
  const roadmap = readRoadmap() || {
    milestones: [],
    currentMilestone: version,
  };

  // Check if milestone already exists
  if (roadmap.milestones.some(m => m.version === version)) {
    logger.error(`Milestone ${version} already exists`);
    return;
  }

  const phases: Phase[] = initialPhases.map((p, index) => ({
    number: index + 1,
    name: p.name,
    description: p.description,
    status: 'pending' as const,
  }));

  roadmap.milestones.push({
    name,
    version,
    phases,
  });

  roadmap.currentMilestone = version;
  roadmap.currentPhase = 1;

  updateRoadmap(roadmap);
  logger.success(`Created milestone: ${name} (${version})`);

  // Update state
  const state = readState() || { decisions: [], blockers: [], notes: [] };
  state.decisions.push({
    date: new Date().toISOString().split('T')[0]!,
    decision: `Started milestone: ${name} (${version})`,
    rationale: `New development cycle with ${phases.length} phases`,
  });
  state.notes.push(`Ready to begin ${name}`);
  updateState(state);
}

/**
 * Complete and archive current milestone
 */
export function completeMilestone(version?: string): void {
  const roadmap = readRoadmap();
  if (!roadmap) {
    logger.error('No roadmap found');
    return;
  }

  const targetVersion = version || roadmap.currentMilestone;
  const milestone = roadmap.milestones.find(m => m.version === targetVersion);

  if (!milestone) {
    logger.error(`Milestone ${targetVersion} not found`);
    return;
  }

  // Check if all phases are completed
  const incompletePhasesCount = milestone.phases.filter(p => p.status !== 'completed').length;
  if (incompletePhasesCount > 0) {
    logger.warn(`${incompletePhasesCount} phase(s) not completed yet`);
    logger.info('Complete all phases before completing the milestone');
    return;
  }

  // Archive milestone directory
  const archiveDir = path.join(PLANNING_DIR, 'archive', targetVersion);
  if (!fs.existsSync(archiveDir)) {
    fs.mkdirSync(archiveDir, { recursive: true });
  }

  // Archive phase plans
  milestone.phases.forEach(phase => {
    const phaseDir = path.join(PLANNING_DIR, `phase-${phase.number}`);
    const archivePhaseDir = path.join(archiveDir, `phase-${phase.number}`);

    if (fs.existsSync(phaseDir)) {
      fs.mkdirSync(archivePhaseDir, { recursive: true });
      const planPath = path.join(phaseDir, 'PLAN.md');
      const archivePlanPath = path.join(archivePhaseDir, 'PLAN.md');

      if (fs.existsSync(planPath)) {
        fs.copyFileSync(planPath, archivePlanPath);
      }
    }
  });

  // Create milestone summary
  const summary = `# Milestone: ${milestone.name} (${targetVersion})

**Completed:** ${new Date().toISOString().split('T')[0]}

## Phases

${milestone.phases.map(p => `- ✓ Phase ${p.number}: ${p.name}`).join('\n')}

## Notes

Milestone completed successfully with all ${milestone.phases.length} phases verified.
`;

  fs.writeFileSync(path.join(archiveDir, 'SUMMARY.md'), summary);

  logger.success(`✓ Milestone ${targetVersion} completed and archived`);

  // Update state
  const state = readState() || { decisions: [], blockers: [], notes: [] };
  state.decisions.push({
    date: new Date().toISOString().split('T')[0]!,
    decision: `Completed milestone: ${milestone.name} (${targetVersion})`,
    rationale: `All ${milestone.phases.length} phases completed and archived`,
  });
  state.notes = [`Milestone ${targetVersion} archived to ${archiveDir}`];
  updateState(state);

  logger.info('Create a new milestone with /nishi:new-milestone');
}
